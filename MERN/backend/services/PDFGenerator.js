const OpenAI = require('openai');
const fs = require('fs-extra');
const path = require('path');
const PDFDocument = require('pdfkit');

class PDFGenerator {
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    this.outputDir = process.env.OUTPUT_DIR || './output';
  }

  async generatePDF(content, title, taskId, taskManager, wsManager) {
    try {
      // Update task status
      taskManager.updateTask(taskId, {
        status: 'running',
        progress: 20,
        message: 'Generating PDF structure with GPT...'
      });
      wsManager.broadcastTaskUpdate(taskId, taskManager.getTask(taskId));

      // Generate PDF structure using GPT
      const pdfStructure = await this.generatePDFStructure(content, title);
      
      taskManager.updateTask(taskId, {
        progress: 60,
        message: 'Creating PDF document...'
      });
      wsManager.broadcastTaskUpdate(taskId, taskManager.getTask(taskId));

      // Create PDF from structure
      const pdfPath = await this.createPDFFromStructure(pdfStructure, taskId);
      
      if (pdfPath) {
        taskManager.updateTask(taskId, {
          status: 'completed',
          progress: 100,
          message: 'PDF generation completed successfully!',
          data: { pdfPath }
        });
        wsManager.broadcastTaskUpdate(taskId, taskManager.getTask(taskId));
        return pdfPath;
      } else {
        throw new Error('PDF creation failed');
      }

    } catch (error) {
      console.error('PDF generation error:', error);
      taskManager.updateTask(taskId, {
        status: 'failed',
        error: error.message
      });
      wsManager.broadcastTaskUpdate(taskId, taskManager.getTask(taskId));
      throw error;
    }
  }

  async generatePDFStructure(content, title) {
    try {
      const prompt = `
You are a professional PDF document generator. Generate a complete PDF document structure from the given content.

IMPORTANT: You cannot create actual PDF files, but you can generate the complete structure and content that will be converted to PDF.

Generate a JSON structure with the following format:

{
  "title": "${title}",
  "subtitle": "Generated Document",
  "header": {
    "business_name": "The Cozy Corner Café",
    "tagline": "Fresh Food, Great Service",
    "legend": "V = Vegetarian, GF = Gluten-Free"
  },
  "sections": [
    {
      "name": "Section Name",
      "items": [
        {
          "name": "Item Name",
          "description": "Optional description",
          "tags": ["V", "GF"],
          "price": "£X.XX"
        }
      ]
    }
  ],
  "footer": {
    "vat_note": "Prices include VAT",
    "allergy_note": "Please inform us of any allergies",
    "hours": "Open: 9:00am - 11:00pm",
    "address": "123 High Street, London"
  },
  "styling": {
    "primary_color": "#7b5b3e",
    "secondary_color": "#fcfbf9",
    "text_color": "#333333",
    "font_family": "Helvetica"
  }
}

Parse the following content and create this structure:
${content}

Return ONLY the JSON structure, no explanations or markdown.
`;

      const response = await this.openai.chat.completions.create({
        model: 'gpt-4',
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 4000,
        temperature: 0.7
      });

      const jsonContent = response.choices[0].message.content.trim();
      const cleanedJson = this.extractJSONFromResponse(jsonContent);
      
      const pdfStructure = JSON.parse(cleanedJson);
      console.log('✅ PDF structure generated by GPT');
      return pdfStructure;

    } catch (error) {
      console.error('PDF structure generation error:', error);
      throw new Error('Failed to generate PDF structure');
    }
  }

  extractJSONFromResponse(responseText) {
    // Try to find JSON in code blocks
    const jsonPatterns = [
      /```json\s*(.*?)\s*```/s,
      /```\s*(\{.*?\})\s*```/s,
    ];

    for (const pattern of jsonPatterns) {
      const match = responseText.match(pattern);
      if (match) {
        return match[1].trim();
      }
    }

    // Try to find JSON directly
    const jsonStart = responseText.indexOf('{');
    const jsonEnd = responseText.lastIndexOf('}') + 1;

    if (jsonStart !== -1 && jsonEnd > jsonStart) {
      return responseText.substring(jsonStart, jsonEnd);
    }

    return responseText;
  }

  async createPDFFromStructure(structure, taskId) {
    try {
      const filename = `document_${taskId}.pdf`;
      const pdfPath = path.join(this.outputDir, filename);

      // Create PDF using PDFKit
      const doc = new PDFDocument({
        size: 'A4',
        margins: {
          top: 50,
          bottom: 50,
          left: 50,
          right: 50
        }
      });

      // Pipe PDF to file
      doc.pipe(fs.createWriteStream(pdfPath));

      // Add content to PDF
      this.addContentToPDF(doc, structure);

      // Finalize PDF
      doc.end();

      // Wait for PDF to be written
      await new Promise((resolve, reject) => {
        doc.on('end', resolve);
        doc.on('error', reject);
      });
      
      console.log('✅ PDF created from GPT structure');
      return pdfPath;

    } catch (error) {
      console.error('PDF creation error:', error);
      throw new Error('Failed to create PDF file');
    }
  }

  addContentToPDF(doc, structure) {
    // Title
    doc.fontSize(24)
       .font('Helvetica-Bold')
       .fillColor('#7b5b3e')
       .text(structure.title, { align: 'center' });
    
    doc.moveDown(1);

    // Header
    if (structure.header) {
      doc.fontSize(18)
         .font('Helvetica-Bold')
         .fillColor('#333')
         .text(structure.header.business_name || '', { align: 'center' });
      
      if (structure.header.tagline) {
        doc.fontSize(14)
           .font('Helvetica')
           .fillColor('#666')
           .text(structure.header.tagline, { align: 'center' });
      }
      
      if (structure.header.legend) {
        doc.fontSize(12)
           .font('Helvetica')
           .fillColor('#888')
           .text(structure.header.legend, { align: 'center' });
      }
      
      doc.moveDown(2);
    }

    // Sections
    if (structure.sections && structure.sections.length > 0) {
      structure.sections.forEach(section => {
        // Section title
        doc.fontSize(16)
           .font('Helvetica-Bold')
           .fillColor('#7b5b3e')
           .text(section.name || 'Section');
        
        doc.moveDown(0.5);

        // Section items
        if (section.items && section.items.length > 0) {
          section.items.forEach(item => {
            // Item name
            doc.fontSize(12)
               .font('Helvetica-Bold')
               .fillColor('#333')
               .text(item.name || 'Item', { continued: true });
            
            // Tags
            if (item.tags && item.tags.length > 0) {
              doc.fontSize(10)
                 .font('Helvetica')
                 .fillColor('#888')
                 .text(` (${item.tags.join(', ')})`, { continued: true });
            }
            
            // Price (right aligned)
            const price = item.price || '';
            const pageWidth = doc.page.width - doc.page.margins.left - doc.page.margins.right;
            const textWidth = doc.widthOfString(item.name + (item.tags ? ` (${item.tags.join(', ')})` : ''));
            const priceX = doc.page.margins.left + textWidth + 20;
            
            doc.fontSize(12)
               .font('Helvetica-Bold')
               .fillColor('#333')
               .text(price, priceX, doc.y, { width: pageWidth - textWidth - 20, align: 'right' });
            
            doc.moveDown(0.3);
          });
        }
        
        doc.moveDown(1);
      });
    }

    // Footer
    if (structure.footer) {
      doc.moveDown(2);
      
      const footerItems = [
        structure.footer.vat_note,
        structure.footer.allergy_note,
        structure.footer.hours,
        structure.footer.address
      ].filter(item => item);

      footerItems.forEach(item => {
        doc.fontSize(10)
           .font('Helvetica')
           .fillColor('#666')
           .text(item, { align: 'center' });
      });
    }
  }
}

module.exports = PDFGenerator;
